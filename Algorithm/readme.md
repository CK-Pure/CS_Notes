- 此目录下的文件夹为idea项目文件夹
- 收录一些代码

![复杂度](img/1.png)

# 排序算法
## 1.冒泡排序
### 1.1 算法步骤
- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
![具体过程](img/1gif.gif)

### 1.2 优化
冒泡排序不管数组是否有序，都会执行两层循环，浪费资源。因此我们可以设置一个临时遍历来标记是否有序。
### 1.3 特点
- 稳定性：它是指对同样的数据进行排序，会不会改变它的相对位置。比如 [ 1, 3, 2, 4, 2 ] 经过排序后，两个相同的元素 2 位置会不会被交换。冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。

- 空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1);

- 时间复杂度：由于嵌套了 2 层循环，故为 O(n*n);
## 2.选择排序
### 2.1 算法步骤
依次从无序数组中找到最大或最小的元素放到数组最后面。
![具体过程](img/2gif.gif)
### 2.2 特点
- 稳定性：排序过程中元素是按顺序进行遍历，相同元素相对位置不会发生变化，故稳定。
- 空间复杂度：在原序列进行操作，故为 O( 1 );
- 时间复杂度：需要 2 次循环遍历，故为 O( n * n );

## 3.插入排序
### 3.1 算法步骤
![具体步骤](img/3gif.gif)
### 3.2 特点
- 稳定性：它是从后往前遍历已排序好的序列，相同元素不会改变位置，故为稳定排序；
- 空间复杂度：它是在原序列进行排序，故为 O ( 1 );
- 时间复杂度：排序的过程中，首先要遍历所有的元素，然后在已排序序列中找到合适的位置并插入。共需要 2 层循环，故为 O ( n² );

## 4.希尔排序
### 4.1 算法步骤
插入排序的一种高效改进算法。核心思想是把一个序列分组，对分组后的内容进行插入排序，这里的分组只是逻辑上的分组，不会重新开辟存储空间。它其实是插入排序的优化版，插入排序对基本有序的序列性能好，希尔排序利用这一特性把原序列分组，对每个分组进行排序，逐步完成排序。
![具体步骤](img/4gif.gif)